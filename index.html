<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è MINIGAME 3D ¬∑ INIMIGOS VIS√çVEIS ¬∑ CORRIGIDO</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Quicksand:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Quicksand', sans-serif; color: white; cursor: crosshair; }
        #stats-panel {
            position: absolute; top: 20px; left: 20px; background: rgba(10, 5, 20, 0.85); backdrop-filter: blur(5px);
            border: 3px solid #aa8cff; border-radius: 30px 10px 30px 10px; padding: 15px 25px; z-index: 100;
            box-shadow: 0 0 30px #6a4ec7; border-bottom: 6px solid #5f4bb6; pointer-events: none;
        }
        #player-stats { display: flex; align-items: center; gap: 20px; flex-wrap: wrap; }
        .avatar-icon { font-size: 3rem; filter: drop-shadow(0 0 10px gold); }
        .stat-bars { min-width: 200px; }
        .hp-bar, .mana-bar { height: 15px; background: #2a1e3a; border-radius: 30px; border: 2px solid #b886ff; margin: 5px 0; overflow: hidden; }
        .hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ec5252, #ff7b7b); border-radius: 30px; transition: width 0.2s; }
        .mana-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #4287f0, #7aaaff); transition: width 0.2s; }
        
        #skill-panel {
            position: absolute; bottom: 30px; left: 30px; background: rgba(0, 0, 0, 0.75); backdrop-filter: blur(8px);
            border: 3px ridge #9b7ef0; border-radius: 50px 20px 50px 20px; padding: 20px; z-index: 200;
            width: 320px; color: #f0e6d0; box-shadow: 0 0 40px #3a2c6e; pointer-events: none;
        }
        #skill-panel h3 { font-family: 'Press Start 2P', cursive; font-size: 0.8rem; color: #f7d970; margin: 0 0 15px 0; text-align: center; }
        .skill-row { display: flex; align-items: center; margin: 12px 0; gap: 8px; }
        .skill-name { width: 90px; font-size: 0.75rem; font-weight: bold; color: #b3a0ff; }
        .skill-bar-bg { flex: 1; height: 12px; background: #1e192b; border-radius: 20px; border: 1px solid #7a62c4; }
        .skill-bar-fill { height: 100%; background: linear-gradient(90deg, #f9c15d, #fca635); border-radius: 20px; width: 0%; box-shadow: 0 0 8px orange; }
        
        #project-hint {
            position: absolute; bottom: 30px; right: 30px; background: rgba(30, 20, 50, 0.95);
            border: 4px solid #c59aff; border-radius: 40px 10px 40px 10px; padding: 20px; z-index: 200;
            max-width: 280px; backdrop-filter: blur(5px); border-bottom: 8px solid #6f4faf;
            animation: hint-glow 2s infinite alternate; pointer-events: none;
        }
        @keyframes hint-glow { from { box-shadow: 0 0 20px #b67ef0; } to { box-shadow: 0 0 50px #d9b0ff; } }
        #project-hint h4 { font-family: 'Press Start 2P', cursive; font-size: 0.8rem; color: #fedb7a; margin-top: 0; }
        #project-hint ul { padding-left: 20px; font-size: 0.8rem; }
        #project-hint li { list-style-type: "‚öîÔ∏è "; margin: 8px 0; color: #d0c0ff; }
        
        #minigame-ui {
            position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            border: 4px solid #ffaa33; border-radius: 30px; padding: 15px 25px; text-align: center;
            z-index: 300; border-bottom: 8px solid #b37400; color: #ffe9b0; min-width: 260px;
        }
        #minigame-ui h2 { font-family: 'Press Start 2P', cursive; font-size: 0.9rem; margin: 0 0 10px; color: gold; }
        #wave-info { font-size: 1.2rem; font-weight: bold; text-shadow: 0 0 10px cyan; }
        .skill-buttons {
            display: flex; gap: 10px; justify-content: center; margin: 15px 0 8px;
        }
        .skill-btn {
            background: #2f2660; border: 3px solid #9b7ef0; border-radius: 20px 5px 20px 5px;
            color: white; font-family: 'Press Start 2P', cursive; font-size: 0.55rem;
            padding: 8px 4px; width: 70px; cursor: pointer; transition: 0.1s; border-bottom: 5px solid #4a2f8c;
            pointer-events: auto; text-shadow: 2px 2px 0 #000;
        }
        .skill-btn:hover { transform: translateY(-3px); background: #4d3a94; border-color: #ffb86b; }
        .skill-btn:active { transform: translateY(3px); border-bottom-width: 2px; }
        #minigame-status { margin-top: 8px; font-size: 0.8rem; min-height: 40px; color: #aaffaa; }
        
        #control-info {
            position: absolute; bottom: 180px; right: 30px; background: rgba(20,20,40,0.8);
            padding: 12px 20px; border-radius: 40px; font-size: 0.75rem; border: 2px solid #88ffaa; z-index: 350;
            color: #ccffcc; backdrop-filter: blur(4px);
        }
        #score-board {
            position: absolute; top: 150px; left: 20px; background: rgba(0,0,0,0.5);
            padding: 10px 20px; border-radius: 30px; border: 2px solid gold; font-size: 1.2rem;
            font-family: 'Press Start 2P', cursive; color: #ffd966; z-index: 400;
        }
        #combo-indicator {
            position: absolute; top: 220px; left: 20px; color: #ff88ff; font-size: 1rem;
            text-shadow: 0 0 10px magenta; z-index: 400;
        }
    </style>
</head>
<body>
    <!-- Pain√©is de UI -->
    <div id="stats-panel">
        <div id="player-stats">
            <div class="avatar-icon"><i class="fas fa-hat-wizard"></i></div>
            <div class="stat-bars">
                <div style="display: flex; justify-content: space-between;"><span><i class="fas fa-heart" style="color:#ff6b6b;"></i> HP</span><span id="hp-text">100/100</span></div>
                <div class="hp-bar"><div class="hp-fill" id="player-hp-fill" style="width:100%"></div></div>
                <div style="display: flex; justify-content: space-between; margin-top: 5px;"><span><i class="fas fa-magic" style="color:#6ba6ff;"></i> MANA</span><span id="mana-text">80/100</span></div>
                <div class="mana-bar"><div class="mana-fill" id="player-mana-fill" style="width:80%"></div></div>
            </div>
        </div>
        <div style="margin-top: 10px; font-family: 'Press Start 2P'; font-size: 0.6rem; color: #d9b38c;">LV. 25 ¬∑ ARQUIMAGO JAVA</div>
    </div>

    <div id="skill-panel">
        <h3><i class="fas fa-crown" style="color: gold;"></i> JAVA MASTERY <i class="fas fa-crown" style="color: gold;"></i></h3>
        <div class="skill-row"><span class="skill-name">CORE</span><div class="skill-bar-bg"><div class="skill-bar-fill" style="width:95%"></div></div></div>
        <div class="skill-row"><span class="skill-name">SPRING</span><div class="skill-bar-bg"><div class="skill-bar-fill" style="width:88%"></div></div></div>
        <div class="skill-row"><span class="skill-name">JAKARTA</span><div class="skill-bar-bg"><div class="skill-bar-fill" style="width:80%"></div></div></div>
        <div class="skill-row"><span class="skill-name">JAVAFX</span><div class="skill-bar-bg"><div class="skill-bar-fill" style="width:75%"></div></div></div>
        <div class="skill-row"><span class="skill-name">QUARKUS</span><div class="skill-bar-bg"><div class="skill-bar-fill" style="width:82%"></div></div></div>
    </div>

    <div id="project-hint">
        <h4>üì¶ PROJETOS</h4>
        <ul>
            <li><strong>RPG Combat API</strong> (Java 21 + Spring)</li>
            <li><strong>Dungeon Builder</strong> (JavaFX)</li>
            <li><strong>QuestLog</strong> (Quarkus + Kafka)</li>
            <li><strong>ByteCraft</strong> (compilador)</li>
            <li><strong>Reactor Flux</strong> (WebFlux)</li>
        </ul>
    </div>

    <!-- MINIGAME UI -->
    <div id="minigame-ui">
        <h2><i class="fas fa-dragon"></i> JAVA DEFENDER <i class="fas fa-dragon"></i></h2>
        <div id="wave-info">üåä ONDA 1</div>
        <div style="margin: 8px 0;">‚öîÔ∏è Inimigos: <span id="enemy-count">5</span></div>
        <div style="margin: 8px 0;">üíÄ Abates: <span id="kill-count">0</span></div>
        <div class="skill-buttons">
            <div class="skill-btn" id="skill-core" onclick="useSkill('core')">‚òï CORE</div>
            <div class="skill-btn" id="skill-spring" onclick="useSkill('spring')">üçÉ SPRING</div>
            <div class="skill-btn" id="skill-jfx" onclick="useSkill('jfx')">üñ•Ô∏è FX</div>
        </div>
        <div id="minigame-status">‚ú® Clique nos inimigos para atacar!</div>
    </div>

    <div id="control-info">
        <i class="fas fa-arrow-up"></i> <i class="fas fa-arrow-down"></i> <i class="fas fa-arrow-left"></i> <i class="fas fa-arrow-right"></i> MOVER | 
        <i class="fas fa-mouse-pointer"></i> CLIQUE NOS INIMIGOS
    </div>
    
    <div id="score-board">
        <span id="score-value">0</span> PONTOS
    </div>
    <div id="combo-indicator">
        <span id="combo-value">0</span>x COMBO
    </div>

    <!-- Import Three.js de forma compat√≠vel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Garantir que o Three.js carregou
        console.log('Three.js carregado:', THREE);
        
        // --- CENA, C√ÇMERA, RENDERIZADORES ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0c0c1a);
        scene.fog = new THREE.Fog(0x0c0c1a, 10, 30);
        
        // Estrelas
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 2000;
        const starsPositions = new Float32Array(starsCount * 3);
        for (let i = 0; i < starsCount * 3; i += 3) {
            starsPositions[i] = (Math.random() - 0.5) * 200;
            starsPositions[i+1] = (Math.random() - 0.5) * 200;
            starsPositions[i+2] = (Math.random() - 0.5) * 200;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));
        const starsMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 0.2});
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 12);
        camera.lookAt(0, 2, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Controles de √≥rbita
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 5;
        controls.maxDistance = 20;
        controls.target.set(0, 2, 0);

        // --- ILUMINA√á√ÉO ---
        const ambientLight = new THREE.AmbientLight(0x40406b);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
        dirLight.position.set(5, 12, 8);
        dirLight.castShadow = true;
        dirLight.receiveShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        const d = 8;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 2;
        dirLight.shadow.camera.far = 20;
        scene.add(dirLight);
        
        const pointLight1 = new THREE.PointLight(0x4466ff, 0.8, 10);
        pointLight1.position.set(-2, 4, 3);
        scene.add(pointLight1);
        const pointLight2 = new THREE.PointLight(0xff44aa, 0.5, 10);
        pointLight2.position.set(3, 3, -4);
        scene.add(pointLight2);

        // --- ARENA CIRCULAR ---
        const arenaRadius = 5;
        const groundGeometry = new THREE.CircleGeometry(arenaRadius, 32);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x1e1a30, roughness: 0.7, metalness: 0.1 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grade decorativa
        const gridHelper = new THREE.GridHelper(arenaRadius*2, 20, 0xaa88ff, 0x443388);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);
        
        // Bordas da arena
        const wallRingGeo = new THREE.TorusGeometry(arenaRadius, 0.2, 16, 50);
        const wallRingMat = new THREE.MeshStandardMaterial({ color: 0x6a4ec7, emissive: 0x1a0f3a });
        const wallRing = new THREE.Mesh(wallRingGeo, wallRingMat);
        wallRing.rotation.x = Math.PI / 2;
        wallRing.position.y = 0.5;
        scene.add(wallRing);
        
        // Pilares decorativos
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const x = Math.cos(angle) * arenaRadius;
            const z = Math.sin(angle) * arenaRadius;
            const pillarGeo = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 6);
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x8866cc });
            const pillar = new THREE.Mesh(pillarGeo, pillarMat);
            pillar.position.set(x, 0.75, z);
            pillar.castShadow = true;
            pillar.receiveShadow = true;
            scene.add(pillar);
        }

        // --- BONECO DO JOGADOR ---
        const playerGroup = new THREE.Group();
        playerGroup.position.set(0, 0, 0);
        playerGroup.castShadow = true; 
        playerGroup.receiveShadow = true;
        
        // Corpo
        const bodyGeo = new THREE.CylinderGeometry(0.7, 0.8, 1.6, 8);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4a3a7a, emissive: 0x110a22 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.8; body.castShadow = true; body.receiveShadow = true;
        playerGroup.add(body);
        
        // Cabe√ßa
        const headGeo = new THREE.SphereGeometry(0.5, 24);
        const headMat = new THREE.MeshStandardMaterial({ color: 0xf5dbb1 });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 1.7; head.castShadow = true; head.receiveShadow = true;
        playerGroup.add(head);
        
        // Chap√©u
        const hatConeGeo = new THREE.ConeGeometry(0.5, 1.0, 8);
        const hatMat = new THREE.MeshStandardMaterial({ color: 0x8855cc, emissive: 0x220044 });
        const hatCone = new THREE.Mesh(hatConeGeo, hatMat);
        hatCone.position.y = 2.3; hatCone.castShadow = true;
        playerGroup.add(hatCone);
        
        // Olhos
        const eyeGeo = new THREE.SphereGeometry(0.1, 8);
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        
        const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.18, 1.8, 0.45); playerGroup.add(eyeL);
        const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6), pupilMat); pupilL.position.set(-0.18, 1.8, 0.55); playerGroup.add(pupilL);
        const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(0.18, 1.8, 0.45); playerGroup.add(eyeR);
        const pupilR = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6), pupilMat); pupilR.position.set(0.18, 1.8, 0.55); playerGroup.add(pupilR);
        
        // Cajado
        const staffGroup = new THREE.Group(); staffGroup.position.set(1.0, 0.7, 0.3);
        const staffBaseGeo = new THREE.CylinderGeometry(0.08, 0.08, 2.2);
        const staffMat = new THREE.MeshStandardMaterial({ color: 0xa57c5c });
        const staffBase = new THREE.Mesh(staffBaseGeo, staffMat); staffBase.position.y = 1.1; staffBase.rotation.z = 0.3; staffBase.castShadow = true; staffGroup.add(staffBase);
        
        const staffTopGeo = new THREE.SphereGeometry(0.3);
        const staffTopMat = new THREE.MeshStandardMaterial({ color: 0xffaa44, emissive: 0x442200 });
        const staffTop = new THREE.Mesh(staffTopGeo, staffTopMat); staffTop.position.set(0.5, 2.3, 0.1); staffTop.castShadow = true; staffGroup.add(staffTop);
        
        const gemLight = new THREE.PointLight(0xffaa44, 1, 4); gemLight.position.set(0.5, 2.3, 0.1); staffGroup.add(gemLight);
        playerGroup.add(staffGroup);
        
        scene.add(playerGroup);

        // --- INIMIGOS ---
        const enemies = [];
        let killCount = 0;
        let score = 0;
        let combo = 0;
        let lastKillTime = 0;
        
        class Enemy {
            constructor(x, z, type = 'normal') {
                this.type = type;
                
                const colors = { 
                    normal: 0xff5555,
                    fast: 0xffaa44,
                    tank: 0xaa4444,
                    boss: 0x9922aa
                };
                
                const geo = new THREE.SphereGeometry(type === 'boss' ? 0.7 : 0.45, 16);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: colors[type] || 0xff5555, 
                    emissive: 0x220000,
                    shininess: 30
                });
                
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.set(x, 0.8, z);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                
                // Olhos
                const eyeGeo = new THREE.SphereGeometry(0.1, 6);
                const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const pupilGeo = new THREE.SphereGeometry(0.05, 4);
                const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
                eye1.position.set(-0.15, 0.15, 0.4);
                this.mesh.add(eye1);
                
                const pupil1 = new THREE.Mesh(pupilGeo, pupilMat);
                pupil1.position.set(-0.15, 0.15, 0.5);
                this.mesh.add(pupil1);
                
                const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
                eye2.position.set(0.15, 0.15, 0.4);
                this.mesh.add(eye2);
                
                const pupil2 = new THREE.Mesh(pupilGeo, pupilMat);
                pupil2.position.set(0.15, 0.15, 0.5);
                this.mesh.add(pupil2);
                
                // Barra de vida
                const barBgGeo = new THREE.PlaneGeometry(1.0, 0.15);
                const barBgMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
                this.healthBarBg = new THREE.Mesh(barBgGeo, barBgMat);
                this.healthBarBg.position.y = 1.0;
                this.healthBarBg.rotation.x = -Math.PI / 2;
                this.mesh.add(this.healthBarBg);
                
                const barGeo = new THREE.PlaneGeometry(0.96, 0.11);
                const barMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
                this.healthBar = new THREE.Mesh(barGeo, barMat);
                this.healthBar.position.y = 1.0;
                this.healthBar.position.z = 0.02;
                this.healthBar.rotation.x = -Math.PI / 2;
                this.mesh.add(this.healthBar);
                
                this.health = type === 'tank' ? 6 : (type === 'boss' ? 12 : 3);
                if (type === 'fast') this.health = 2;
                this.maxHealth = this.health;
                this.speed = type === 'fast' ? 0.045 : (type === 'boss' ? 0.018 : 0.028);
                this.damage = type === 'boss' ? 25 : 10;
                
                this.updateHealthBar();
                
                scene.add(this.mesh);
                enemies.push(this);
            }
            
            updateHealthBar() {
                const percent = this.health / this.maxHealth;
                this.healthBar.scale.x = percent;
                this.healthBar.position.x = (1 - percent) * 0.48;
                
                if (percent > 0.6) this.healthBar.material.color.setHex(0x00ff00);
                else if (percent > 0.3) this.healthBar.material.color.setHex(0xffff00);
                else this.healthBar.material.color.setHex(0xff0000);
            }
            
            takeDamage(dmg) {
                this.health -= dmg;
                this.updateHealthBar();
                
                this.mesh.material.emissive.setHex(0x550000);
                setTimeout(() => this.mesh.material.emissive.setHex(0x220000), 150);
                
                return this.health <= 0;
            }
        }

        // Criar inimigos iniciais
        function spawnWave(waveNum) {
            const count = 4 + waveNum;
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2 + Math.random() * 0.5;
                const radius = arenaRadius - 1.2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                let type = 'normal';
                if (waveNum > 2 && i % 3 === 0) type = 'fast';
                if (waveNum > 4 && i % 5 === 0) type = 'tank';
                if (waveNum > 6 && i === 0) type = 'boss';
                
                new Enemy(x, z, type);
            }
            updateEnemyCount();
        }

        // Inicial
        spawnWave(1);

        // --- VARI√ÅVEIS DO JOGO ---
        let wave = 1;
        let hp = 100;
        let mana = 80;
        const maxMana = 100;
        let gameActive = true;
        
        // Elementos UI
        const hpFill = document.getElementById('player-hp-fill');
        const hpText = document.getElementById('hp-text');
        const manaFill = document.getElementById('player-mana-fill');
        const manaText = document.getElementById('mana-text');
        const enemyCountSpan = document.getElementById('enemy-count');
        const killCountSpan = document.getElementById('kill-count');
        const scoreSpan = document.getElementById('score-value');
        const comboSpan = document.getElementById('combo-value');
        const waveInfo = document.getElementById('wave-info');
        const statusDiv = document.getElementById('minigame-status');

        function updateEnemyCount() {
            enemyCountSpan.innerText = enemies.length;
        }

        function updateUI() {
            hpFill.style.width = hp + '%';
            hpText.innerText = hp + '/100';
            manaFill.style.width = mana + '%';
            manaText.innerText = mana + '/100';
            killCountSpan.innerText = killCount;
            scoreSpan.innerText = score;
            
            combo = Math.max(0, combo - 0.005);
            comboSpan.innerText = Math.floor(combo * 10) / 10;
        }

        // --- CONTROLE DO BONECO ---
        const keyState = { w: false, a: false, s: false, d: false };
        window.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': keyState.w = true; e.preventDefault(); break;
                case 's': case 'arrowdown': keyState.s = true; e.preventDefault(); break;
                case 'a': case 'arrowleft': keyState.a = true; e.preventDefault(); break;
                case 'd': case 'arrowright': keyState.d = true; e.preventDefault(); break;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': keyState.w = false; e.preventDefault(); break;
                case 's': case 'arrowdown': keyState.s = false; e.preventDefault(); break;
                case 'a': case 'arrowleft': keyState.a = false; e.preventDefault(); break;
                case 'd': case 'arrowright': keyState.d = false; e.preventDefault(); break;
            }
        });

        function movePlayer() {
            if (!gameActive) return;
            const speed = 0.1;
            let dx = 0, dz = 0;
            if (keyState.w) dz -= speed;
            if (keyState.s) dz += speed;
            if (keyState.a) dx -= speed;
            if (keyState.d) dx += speed;
            
            if (dx !== 0 || dz !== 0) {
                const newX = playerGroup.position.x + dx;
                const newZ = playerGroup.position.z + dz;
                const dist = Math.sqrt(newX*newX + newZ*newZ);
                if (dist <= arenaRadius - 0.8) {
                    playerGroup.position.x = newX;
                    playerGroup.position.z = newZ;
                } else {
                    const angle = Math.atan2(newZ, newX);
                    playerGroup.position.x = Math.cos(angle) * (arenaRadius - 0.8);
                    playerGroup.position.z = Math.sin(angle) * (arenaRadius - 0.8);
                }
                controls.target.copy(playerGroup.position.clone().add(new THREE.Vector3(0, 2, 0)));
            }
        }

        // --- SISTEMA DE ATAQUE COM CLIQUE ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('click', (event) => {
            if (!gameActive) return;
            
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const enemyMeshes = enemies.map(e => e.mesh);
            const intersects = raycaster.intersectObjects(enemyMeshes);
            
            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                const enemy = enemies.find(e => e.mesh === hitMesh);
                if (enemy) {
                    const now = Date.now();
                    if (now - lastKillTime < 2000) {
                        combo += 0.5;
                    } else {
                        combo = 1;
                    }
                    lastKillTime = now;
                    
                    const dmg = 2 + Math.floor(combo / 2);
                    const killed = enemy.takeDamage(dmg);
                    
                    if (killed) {
                        scene.remove(enemy.mesh);
                        const index = enemies.indexOf(enemy);
                        if (index > -1) enemies.splice(index, 1);
                        killCount++;
                        score += 10 * (enemy.type === 'boss' ? 5 : 1) * (1 + combo/10);
                        
                        if (enemies.length === 0) {
                            wave++;
                            waveInfo.innerText = `üåä ONDA ${wave}`;
                            spawnWave(wave);
                            statusDiv.innerText = '‚ú® Nova onda!';
                        }
                    }
                    
                    for (let i = 0; i < 8; i++) {
                        const sparkGeo = new THREE.SphereGeometry(0.05, 3);
                        const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                        const spark = new THREE.Mesh(sparkGeo, sparkMat);
                        spark.position.copy(hitMesh.position.clone().add(
                            new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.8, (Math.random()-0.5)*0.5)
                        ));
                        scene.add(spark);
                        setTimeout(() => scene.remove(spark), 100);
                    }
                    
                    updateEnemyCount();
                    updateUI();
                }
            }
        });

        // --- HABILIDADES ---
        window.useSkill = (skill) => {
            if (!gameActive) return;
            if (enemies.length === 0) {
                statusDiv.innerText = 'Nenhum inimigo!';
                return;
            }
            
            let manaCost = 20;
            if (skill === 'core') manaCost = 25;
            if (skill === 'spring') manaCost = 20;
            if (skill === 'jfx') manaCost = 15;
            
            if (mana < manaCost) {
                statusDiv.innerText = '‚ùå Mana insuficiente!';
                return;
            }
            
            mana -= manaCost;
            
            let damage = 0;
            let effect = '';
            if (skill === 'core') { damage = 5; effect = 'üí• CORE: Dano massivo!'; }
            if (skill === 'spring') { damage = 3; effect = 'üçÉ SPRING: Dano em √°rea!'; }
            if (skill === 'jfx') { damage = 4; effect = 'üñ•Ô∏è FX: Interface letal!'; }
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const killed = enemy.takeDamage(damage);
                if (killed) {
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    killCount++;
                    score += 15;
                }
            }
            
            if (enemies.length === 0) {
                wave++;
                waveInfo.innerText = `üåä ONDA ${wave}`;
                spawnWave(wave);
            }
            
            statusDiv.innerText = effect;
            updateEnemyCount();
            updateUI();
        };

        // --- ANIMA√á√ÉO DOS INIMIGOS ---
        function updateEnemies() {
            if (!gameActive) return;
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.mesh.position).normalize();
                enemy.mesh.position.x += dir.x * enemy.speed;
                enemy.mesh.position.z += dir.z * enemy.speed;
                
                const dist = Math.sqrt(enemy.mesh.position.x*enemy.mesh.position.x + enemy.mesh.position.z*enemy.mesh.position.z);
                if (dist > arenaRadius - 0.6) {
                    const angle = Math.atan2(enemy.mesh.position.z, enemy.mesh.position.x);
                    enemy.mesh.position.x = Math.cos(angle) * (arenaRadius - 0.6);
                    enemy.mesh.position.z = Math.sin(angle) * (arenaRadius - 0.6);
                }
                
                if (enemy.mesh.position.distanceTo(playerGroup.position) < 1.0) {
                    hp -= enemy.damage;
                    hp = Math.max(0, hp);
                    updateUI();
                    
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    
                    if (hp <= 0) {
                        gameActive = false;
                        statusDiv.innerText = 'üíÄ GAME OVER';
                    }
                }
            }
            
            if (mana < maxMana) {
                mana = Math.min(maxMana, mana + 0.1);
                updateUI();
            }
        }

        // --- LOOP PRINCIPAL ---
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                movePlayer();
                updateEnemies();
                
                stars.rotation.y += 0.0005;
                
                const time = performance.now() / 500;
                playerGroup.position.y = Math.sin(time) * 0.05;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Inicializa UI
        updateUI();
        updateEnemyCount();
        
        console.log('Jogo iniciado com sucesso!');
    </script>
</body>
</html>
